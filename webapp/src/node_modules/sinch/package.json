{
  "author": {
    "name": "Michelle Steigerwalt",
    "email": "msteigerwalt@gmail.com"
  },
  "name": "sinch",
  "description": "A powerful wrapper for interfaces which creates extendable, synchronisity-agnostic interfaces which can be seamlessly passed around to other desynchronous interfaces as if they were synchronous arguments.",
  "version": "0.4.0",
  "homepage": "http://github.com/Yuffster/sinch",
  "main": "./sinch.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/Yuffster/sinch"
  },
  "scripts": {
    "test": "node tests/tests.js"
  },
  "readme": "![Sinch](logo.png)\n\n---\n\n[![Build Status](https://secure.travis-ci.org/Yuffster/sinch.png)](http://travis-ci.org/Yuffster/sinch)\n\n---\n\nSinch sends your asynchronous code into a **patent-pending parallel dimension** \nwhere time has no meaning and everything acts as though it's synchronous.\n\nDon't worry, your code will still run asynchronously, just the way your wrote\nit.  Sinch isn't some sort of fly-by-night snake oil that promises the moon and\ndelivers an empty bottle of promises.\n\nEven if Sinch *were* snake oil, it would be the classy kind of snake oil that's\nactually fine whiskey and only pretends to be medicinal to get around\nProhibition-era liquor laws. Except in this case, think of \"medicinal\" as\n\"synchronous\" and \"Prohibition-era liquor laws\" as \"callbacks\", and \"fine\nwhiskey\" as \"rock-solid code with a full test barrage and one dead-simple API\nmethod.\"\n\nWhy would you ever go back to drinking bathtub hooch?\n\nSo nudge nudge, wink wink, why not enjoy our \"synchronous\" API?\n\nWant to return objects from asynchronous calls and call methods of those objects\n*immediately*?  Go ahead.\n\nWant to follow the convention of having your callbacks as the last argument, \nbut hate having to shift variables around for optional parameters?  That\ndoesn't exist at all in our parallel dimension.\n\nWant to be able to use callbacks or return statements where they makes sense,\nbut have your classes and APIs always work consistently?  Done.\n\nWant to protect your interface's object internal data from pesky developers?\nThat's automatic.\n\nWant to chain procedurally asynchronous interfaces which return other\nasynchronous interfaces without executing a single thing until you need the \ndata?  You can do that now.\n\nWant to pass the results of an asynchronous method to any other function as if \nit were a normal everyday argument?  You can do that.  No, really.\n\nWant to make make an asynchronous GET request to a remote server, and pass \nit to a method that looks in the content to see if there are any bees specified,\nthen spawns and returns a new BeeCollection(), full of buzzy asynchronous\nbees who only exist in the future, which you can then manipulate at will, and\nthen pass that BeeCollection into a Template class that outputs a HTML list of\nall your favorite bees, along with their temperaments, all without writing a \nsingle callback?  It's a little bit of an odd request, but you can totally do\nthat.\n\nYou might be asking yourself, *How is this even possible?*, and hoping that\nI'd stop talking about parallel dimensions and 1920's American history and just\ntell you how the damn thing works.\n\nSinch uses a callback at the very end of your execution chain to see what\ndata came from all of it, which kicks off a huge queue of everything leading up\nto that value.  When you pass the \"results\" of Sinch API operation to another\nSinch function, the data will be desynchronized using a hidden callback before\nbeing passed into the other Sinch function.\n\n---\n\n## Boring Technical Description \n\nSinch is a lightweight, powerful JavaScript module which allows developers\nto create APIs which act in a consistent manner regardless of whether they are\nsynchronous (returning their values immediately) or asynchronous (forcing the\nuser to utilize a callback).\n\nAny arguments passed to a Sinch-wrapped function can be manipulated as\nnormal, synchronous arguments.  Using this call-forward pattern, end users are\nable to pass methods from one Sinch API to another without having to\nunderstand that the operations are asynchronous at all.\n\nWhen objects are passed to Sinch, they will be returned as prototype-based\nJavaScript classes. Even if an instantiated object takes some time to\ninitialize, it may be utilized immediately in a procedural fashion, with all\ndata accessible at the end of the chain using callbacks, or passable to other\nSinch-based API endpoints.  Once the object has been fully initialized, all\nqueued commands will be run immediately, properly bound to the newly-created\nscope.\n\nSinch also provides an Extends: keyword to objects which allows for the\nrecursive extension of one Sinch API by another.\n\n## Examples\n\n### Single Functions\n\nLet's start with two simple asynchronous function which call other functions\nwith their values.\n\n\tfunction echo(message, callback) {\n\t\tcallback(\"I'm echoing, \"+message+\".\");\n\t}\n\t\n\tfunction log(message) {\n\t\tconsole.log(message);\n\t}\n\t\nIf we were to call `echo(\"hello world\", console.log)`, we would get the response\nof, \"I'm echoing, hello world.\"  This is how traditional modules present their\nasynchronous methods.\n\nThe problem with that is that the end user must create an intermediary anonymous\nfunction each time it's necessary to pass a value from one endpoint to another.\nThis code would end up logging to the console, \"I'm echoing, hello world.\"\n\n\techo('hello world', function(message) {\n\t\tlog(message);\n\t});\n\t\nThis is a pattern that JavaScript developers are very used to!  However, if we\nwere to wrap both `log` and `echo` into Sinch, we would--without sacrificing\nour asynchronous nature--be able to present a much clear API to developers using\nour code, which is indistinguishable from procedural code.\n\nThis code would have the exact same effect as the previous code.  In fact, the\nprevious code can still be used when wrapping methods in Sinch.\n\n\tvar echo = sinch(function(message, callback) {\n\t\tthis.callback(\"I'm echoing, \"+message+\".\");\n\t});\n\t\n\tvar log = sinch(function(message) {\n\t\tconsole.log(message);\n\t});\n\n\tlog(echo(message));\n\nLet's try something a little less abstract, and assume we're using a Sinch-\nbased API which handles file transfers.  We want to chain a lot of asynchronous\nfile operations together in order to piece together a file, and use dynamic\narguments, with the last argument being considered a callback if it's a\nfunction.  This also requires that we keep track of how many asynchronous\noperations are pending and nest callbacks.\n\nThe code for something like this can get ugly fairly quickly!\n\n\tfunction cat() {\n\t\tvar output, i, files = [], callback;\n\t\tfunction next() {\n\t\t\tif (!callback) return;\n\t\t\tfor (var f in files) if (files[f]) output += files[f];\n\t\t\tcallback(output);\n\t\t}\n\t\tfor (i in arguments) {\n\t\t\t// Dynamic arguments; check the last argument for a callback.\n\t\t\tif (i==arguments.length-1 && typeof arguments[i]==\"function\") {\n\t\t\t\tcallback = arguments[i];\n\t\t\t}\n\t\t\tpending++;\n\t\t\tasync.file_exists(arguments[i], function(success) {\n\t\t\t\tpending--;\n\t\t\t\tif (pending==0) next();\n\t\t\t\tif (!success) return;\n\t\t\t\tpending++;\n\t\t\t\tasync.file_read(arguments[i], function(data) {\n\t\t\t\t\tpending--;\n\t\t\t\t\tfiles[i] = data;\n\t\t\t\t\tif (pending==0) next();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\t\n\tcat('readme.txt', 'file.txt', 'other.txt', console.log);\n\t\nAssuming we didn't want to reinvent the file API, we could refactor the same\ncode using Sinch to be much easier to understand, more pleasant to use, and\nfar less error prone.\n\n\tfunction cat() {\n\t\tvar output = \"\";\n\t\tfor (var i in arguments) output += arguments[i];\n\t\treturn output;\n\t}); cat = sinch(cat);\n\t\n\tfunction read(file, callback) {\n\t\tasync.file_exists(file, function(exists) {\n\t\t\tif (!exists) callback('');\n\t\t\telse async.file_read(file, callback);\n\t\t});\n\t}; read = sinch(read);\n\t\n\tcat(read('readme.txt'), read('file.txt'), read('other.txt'), console.log);\n\nWe could even make the example do even more advanced things without sacrificing\nreadability or adding much code.\n\n\tfunction get(url) { $.ajax(url, callback); }\n\tget = sinch(get);\n\t\n\tcat(read('readme.txt'), get('data.json'), read('other.txt'), console.log);\n\t\nAnd, since Sinch doesn't modify the original values of the objects passed\ninto it, and follows the same standard callback pattern of other JavaScript\ncode, we could simply our code even further.\n\n\tget = sinch($.ajax);\n\n### Dynamic Arguments\n\nSinch provides `this.callback` to all wrapped functions and methods to allow \nfor explicit callback support, which means when we're traversing a dynamic \narguments list, we don't have to manually check the last argument and infer\nwhether or not it's meant to be a callback.\n\nOtherwise, you'd have to do something like this in every function which takes\ndynamic arguments and a callback:\n\n\tfor (var i in arguments) {\n\t\tif (i==arguments.length-1 && typeof arguments[i]==\"function\") {\n\t\t\tcallback = arguments[i];\n\t\t} else {\n\t\t\t//Do your stuff here.\n\t\t}\n\t}\n\n### Optional Parameters with Callback Support\n\nIt also means we can support optional parameters, and error check on them, \nwithout having to worry about an argument possibly being a callback\ninstead of what we're expecting.\n\nFor example, let's say we want to create a function called outputMessage with\nan optional second parameter, and by convention the callback parameter is \nalways last.\n\nWithout Sinch, we would have to do this:\n\n\tfunction outputMessage(msg,name,cb) {\n\t\tif (typeof name==\"function\") {\n\t\t\tcb = name;\n\t\t\tname = \"Someone\";\n\t\t}\n\t\treturn name+\" said: \", msg;\n\t}\n\nHowever, using Sinch, we can make the code much more readable, and focus on\napplication logic rather than parsing our arguments.\n\n\tvar outputMessage = sinch(function(msg,name) {\n\t\tname = name || \"Someone\";\n\t\treturn name+\" said: \"+ msg;\n\t});\n\nOr, asynchronously:\n\n\tvar outputMessage = sinch(function(msg,name) {\n\t\tname = name || \"Someone\";\n\t\tthis.callback(name+\" said: \"+ msg);\n\t});\n\n### Objects\n\nIf we pass an object into Sinch, we'll get back a constructor function with\nmethods attached to its prototype.\n\n\tvar Database = sinch({\n\t\t\n\t\tdblib: require('dblib'),\n\t\t\n\t\texecute: function(op) {\n\t\t\treturn this.dblib.execute(op);\n\t\t},\n\t\t\n\t\tfind: function(filter, callback) {\n\t\t\tthis.execute('find '+filter, callback);\n\t\t}\n\t\t\n\t});\n\t\n\tvar db = new Database();\n\tdb.find('id=1', console.log);\n\t\nWe have two magic property names within this object, `init` and `Extends`.\n\n### Asynchronous Initialization\n\nProviding an init method tells Sinch that this object will take some time to\ninitialize, and that its interface should be presented through a dummy mechanism\nand then queued to be later executed when the object is ready.\n\nFor example:\n\n\tvar Database = sinch({\n\t\n\t\t// [...]\n\t\tinit: function(server, db) {\n\t\t\tvar callback = this.callback;\n\t\t\tthis.dblib.connect(server, db, function() {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t}\n\t\t\n\t});\n\nNote that we can use the exact same code from the previous example to utilize\nthe Database API.  Each method will be executed when all required objects have\ninitialized.\n\n\tvar db = new Database();\n\tdb.find('id=1', console.log);\n\n### Extending \n\nWe could also use `Extends` to extend one API from another.\n\n\tvar LiteDB = sinch({\n\t\n\t\tExtends: Database,\n\t\t\n\t\tdblib: require('dblite')\n\t\t\n\t});\n\n### Interfaces\n\nWith the simple use of a `[type, function]` syntax within object definition, you\ncan let Sinch know it should return a dummy interface of *type*, and run it\nonce everything has been initialized.\n\n\tvar Cat = sinch({\n\t\n\t\tinit: function(name, callback) {\n\t\t\tconsole.log(\"Waking up a cat named\", name);\n\t\t\tsetTimeout(callback, 1000);\n\t\t},\n\t\t\n\t\tcatchMouse: [Mouse, function() { \n\t\t\treturn new Mouse();\n\t\t}]\n\t\t\n\t});\n\nThis allows the user of the interface to work with the returned object as if it\nwere immediately available.\n\n\tnew Cat('Meow-Meow').catchMouse().squeak(console.log);\n\t\nNotice that in catchMouse, we can type simply, `return new Mouse()`, despite the\nfact that Mouse might or might not finish loading immediately, and Cat\ndefinitely won't.\n\nAll of the above methods of writing code are designed to work together.  Try\nthem out and see which patterns seem cleanest to you.\n\n## Roadmap\n\n* Error handling with traditional `(e,data)` callback structure.\n* Configurable timeouts which throw errors",
  "readmeFilename": "README.md",
  "_id": "sinch@0.4.0",
  "dist": {
    "shasum": "963042434df69d19167a3824a09c54c67343fba1",
    "tarball": "https://registry.npmjs.org/sinch/-/sinch-0.4.0.tgz"
  },
  "_from": "sinch@latest",
  "_npmVersion": "1.2.14",
  "_npmUser": {
    "name": "yuffster",
    "email": "msteigerwalt@gmail.com"
  },
  "maintainers": [
    {
      "name": "yuffster",
      "email": "msteigerwalt@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "963042434df69d19167a3824a09c54c67343fba1",
  "_resolved": "https://registry.npmjs.org/sinch/-/sinch-0.4.0.tgz"
}
